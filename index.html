<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dev Kataria | Terminal Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --terminal-bg: #1c1c1c;
            --terminal-fg: #00ff00; /* Green/Lime */
            --prompt-fg: #6fa8ff; /* Blue */
            --dir-fg: #7affc8; /* Light Cyan */
            --file-fg: #ffffff; /* White */
            --exe-fg: #ffc46f; /* Amber/Orange */
        }
        body {
            font-family: 'Fira Code', monospace;
            background-color: #0d0d0d;
            height: 100vh;
            overflow: hidden;
            color: var(--file-fg);
        }
        #terminal-container {
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            max-width: 1000px;
            margin: 0 auto;
        }
        #output-history {
            flex-grow: 1;
            overflow-y: auto;
            /* Scrollbar styling for a cleaner look */
            scrollbar-width: thin;
            scrollbar-color: #333 var(--terminal-bg);
            padding-bottom: 0.5rem;
        }
        .line-output {
            line-height: 1.5;
        }
        .dir-color { color: var(--dir-fg); }
        .file-color { color: var(--file-fg); }
        .exe-color { color: var(--exe-fg); }
        .prompt-color { color: var(--prompt-fg); }
        .error-color { color: #ff6f6f; }
        input[type="text"] {
            caret-color: var(--terminal-fg);
            outline: none;
            background: transparent;
            border: none;
            color: var(--terminal-fg);
            width: 100%;
            padding: 0;
            margin: 0;
        }
        .terminal-shadow {
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.2);
            border: 1px solid rgba(0, 255, 0, 0.1);
        }
    </style>
</head>
<body>

    <div id="terminal-container" class="bg-[var(--terminal-bg)] terminal-shadow rounded-lg mt-4 mb-4">
        
        <!-- Output History Area -->
        <div id="output-history" class="text-sm p-4">
            <!-- Initial content will be injected here -->
        </div>

        <!-- Input Area -->
        <div id="input-line" class="flex items-center p-4 pt-2 border-t border-gray-800">
            <span id="prompt-text" class="prompt-color text-sm font-bold mr-2 whitespace-nowrap"></span>
            <input type="text" id="command-input" autocomplete="off" autofocus class="flex-1 text-sm">
        </div>

    </div>

    <script>
        // --- DATA STRUCTURE: The Virtual File System ---

        const fileSystem = {
            'userDevKataria': {
                'type': 'dir',
                'contents': {
                    'About': {
                        'type': 'dir',
                        'contents': {
                            'readme.txt': {
                            'type': 'file',
                            'content': `Hi, I'm Dev Kataria — a B.Tech graduate in Mathematics and Computing from IIT Delhi, currently working at Samsung R&D.
I develop and deploy Machine Learning and Computer Vision models for real-time applications, focusing on lightweight and efficient deep learning systems.
My recent work includes projects in shape detection, weapon classification, and minimap recognition — all optimized for embedded devices and low-latency environments.
I'm passionate about building AI systems that bridge research and practical deployment.
                            
Skilled in: Python, C++, TensorFlow, ONNX, and OpenCV.`
                            }
                        }
                    },
                    'Experience': {
                        'type': 'dir',
                        'contents': {
                            'SamsungR&D_currentSDE1': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**SAMSUNG R&D | SOFTWARE ENGINEER**  
July 2024 - Present | Noida, Delhi NCR  
- Developed a shape detection model through four iterative versions, using synthetic data for training and applying it to real-world data, with each phase aimed at improving accuracy and generalization for minimap identification on TVs.  
- Built a lightweight weapon detection model using MobileNetV2 and synthetic data to detect FPS games for real-time genre classification.  
- Captured datasets from over 20+ games to enable minimap detection and improve data availability for the ML pipeline.  
- Converted TTS models from PyTorch to TensorFlow via ONNX and optimized them to TFLite for deployment on TVs.` 
                                    } 
                                } 
                            },
                            'PiramalFinance_internship': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**PIRAMAL FINANCE | SOFTWARE ENGINEER INTERN**  
May 2023 - July 2023 | Bangalore, Karnataka  
- Built a GitLab plugin to automate file creation and enable branch-based merge requests, streamlining developer workflows.  
- Developed an API view in Backstage to visualize 700+ services.` 
                                    } 
                                } 
                            }
                        }
                    },

                    'Projects': {
                        'type': 'dir',
                        'contents': {
                            'DSCoin': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**DSCOIN - BUILDING A CRYPTOCURRENCY | JAVA**  
                                        Oct 2021 - Nov 2021 | IIT Delhi  
- Developed a secure cryptocurrency inspired by Bitcoin in Java using AVL trees, Authenticated Linked Lists, and Merkle Trees.  
- Used CRF SHA-256 for authenticated data structures, enabling verification and retrieval.  
- Implemented counterfeit prevention and automatic transactions via digital signatures.` 
                                    } 
                                } 
                            },
                            'AcademicBlockchain': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**ACADEMIC BLOCKCHAIN | JAVA**  
                                        Oct 2021 | IIT Delhi  
- Developed a blockchain system for tamper-proof academic certificates using Merkle Trees.  
- Achieved 106 requests/sec processing with n log n complexity for record retrieval.` 
                                    } 
                                } 
                            },
                            'DataMiningML': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**DATA MINING (ML) | PYTHON**  
                                        Jan 2023 - May 2023 | IIT Delhi  
- Explored the ESRB dataset using Random Forests, Gaussian Naive Bayes, ANN, KNN, and SVM to predict game ratings.  
- Identified patterns using Apriori and FP-Tree algorithms, evaluating models based on F1 score, accuracy, recall, and precision.  
- Applied tuning techniques like grid search and randomized search for hyperparameter tuning, utilizing K-fold cross validation.` 
                                    } 
                                } 
                            },
                            'OperatingSystems': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**OPERATING SYSTEMS | C**  
                                        July 2023 - Dec 2023 | IIT Delhi  
- Built a Linux-like shell with background execution, pipes, and I/O redirection.  
- Developed a process scheduling simulator using round-robin and multi-level feedback queues.` 
                                    } 
                                } 
                            }
                        }
                    },

                    'Education': {
                        'type': 'dir',
                        'contents': {
                            'IITDelhi_BTech': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**IIT DELHI**
- B.TECH IN MATHEMATICS AND COMPUTING | GPA 7.2
- Nov 2020 - May 2024 | Delhi, India
- Relevant Coursework: Data Structures and Algorithms, Digital Electronics, Analysis & Design of Algorithms, Operating Systems, Data Mining (ML), Computer Architecture, Cryptography` 
                                    } 
                                } 
                            },
                            'GHKPS_SeniorSecondary': { 
                                'type': 'dir', 
                                'contents': { 
                                    'readme.txt': { 
                                        'type': 'file', 
                                        'content': `**Guru Harkrishan Public School, New Delhi**
- Senior Secondary Education (2017 - 2019)
- Score: 95.2%` 
                                    } 
                                } 
                            },
                        }
                    },


                    'Skills': {
                        'type': 'dir',
                        'contents': {
                            'ProgrammingLanguages.txt': { 
                                'type': 'file', 
                                'content': `**PROGRAMMING LANGUAGES** : C++, Python, C, Java` 
                            },
                            'ToolsAndLibraries.txt': { 
                                'type': 'file', 
                                'content': `**TOOLS AND LIBRARIES** : Linux, Git, Grafana, SonarQube, Figma, OpenCV, TensorFlow, ONNX, ONNX Runtime, MATLAB, Jupyter` 
                            }
                        }
                    },

                    'Achievements': {
                        'type': 'dir',
                        'contents': {
                            'readme.txt': {
                                'type': 'file',
                                'content': `**Key Achievements**
- Secured All India Rank 1559 in JEE Advanced 2020
- SWC Professional: Cleared the Samsung SWC Professional, winning a cash prize of Rs.50,000
- SWC Advanced: Cleared the Samsung SWC Advanced, exhibiting proficiency in Data Structures and Algorithms`
                            }
                        }    
                    },


                    'ExtraCurriculars': { 
                        'type': 'dir', 
                        'contents': { 
                            'readme.txt': { 
                                'type': 'file', 
                                'content': `**EXTRACURRICULAR**  
- Coordinator, SInC: Led website development and organized outreach to startups and VCs.  
- BSW Mentor: Guided 5 freshmen through their academic and social transition at IIT Delhi.` 
                            } 
                        } 
                    },

                    // Located within the fileSystem object, inside 'userDevKataria' -> 'contents' -> 'Contact'
                    'Contact': {
                        'type': 'dir',
                        'contents': {
                            'linkedin.exe': { 'type': 'link', 'content': 'https://www.linkedin.com/in/dev-kataria-92a0951ba/' }, 
                            'email.exe': { 
                                'type': 'link', 
                                'content': 'https://mail.google.com/mail/?view=cm&fs=1&to=devkataria.iitd@gmail.com&su=Interview%20Invitation&body=Dear%20Dev,%0A%0AYou%20have%20been%20invited%20for%20an%20interview%20at%20our%20company.%20Please%20reply%20with%20an%20appropriate%20timing%20slot%20for%20interview%20scheduling.%0A%0AThank%20You,%0AHR%20Team' 
                            },
                            'getContacts.txt': { 
                                'type': 'file',
                                'content': `Email: devkataria.iitd@gmail.com
Phone: +91-8385954024
LinkedIn: https://www.linkedin.com/in/dev-kataria-92a0951ba/` 
                            }
                        }
                    },

                    'info.txt': { 'type': 'file', 'content': 'Welcome to Dev Kataria\'s terminal portfolio!\n\nAvailable Commands:\n- info/help: Display this message.\n- ls: List files and directories.\n- cd: Change directory (use \'..\' to go up).\n- cat <file>: Display file contents.\n- clear: Clear the terminal.\n- whoami: Display user context.\n- open : Execute virtual executables (e.g., open linkedin.exe).\n\nStart by typing \'ls\' or \'cd About\'\n' }
                }
            }
        };


        // --- STATE AND DOM ELEMENTS ---

        const outputHistory = document.getElementById('output-history');
        const commandInput = document.getElementById('command-input');
        const promptText = document.getElementById('prompt-text');

        // Initial current working directory (CWD) path, starting at root folder
        let cwd = ['userDevKataria'];
        let commandHistory = [];
        let historyIndex = -1;

        const userName = 'guest';
        const hostName = 'devkataria.com';

        // --- UTILITY FUNCTIONS ---

        /** Returns the current directory object in the fileSystem based on the cwd path array. */
        const getCurrentDir = () => {
            let current = fileSystem;
            for (const dirName of cwd) {
                if (current[dirName] && current[dirName].type === 'dir') {
                    current = current[dirName].contents;
                } else {
                    // This should theoretically not happen if navigation is correct
                    return null;
                }
            }
            return current;
        };

        /** Updates the prompt display with the current working directory. */
        const updatePrompt = () => {
            const currentPath = '~/' + (cwd.length > 1 ? cwd.slice(1).join('/') : '');
            promptText.innerHTML = `<span class="prompt-color">${userName}@${hostName}</span>:<span class="dir-color">${currentPath}</span>$`;
        };

        /** Appends an output line to the terminal history. */
        const printOutput = (htmlContent, isError = false) => {
            const outputDiv = document.createElement('div');
            outputDiv.className = `line-output ${isError ? 'error-color' : 'text-[var(--terminal-fg)]'} whitespace-pre-wrap`;
            outputDiv.innerHTML = htmlContent;
            outputHistory.appendChild(outputDiv);
            outputHistory.scrollTop = outputHistory.scrollHeight; // Scroll to bottom
        };

        /** Prints the user's executed command line. */
        const printCommand = (command) => {
            printOutput(`<span class="prompt-color">${userName}@${hostName}</span>:<span class="dir-color">~/${cwd.slice(1).join('/')}</span>$ ${command}`, false);
        };

        /** Converts markdown style content to HTML (simple bold/newline conversion). */
        const formatContent = (content) => {
            let html = content.replace(/\n/g, '<br>');
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            return html;
        }

        // --- COMMAND HANDLERS ---

        /** Displays help/info message. */
        const handleInfo = () => {
            const rootContents = fileSystem.userDevKataria.contents;
            const infoFile = rootContents['info.txt'];
            if (infoFile && infoFile.type === 'file') {
                printOutput(formatContent(infoFile.content));
            }
        };

        /** Lists contents of the current directory. */
        const handleLs = () => {
            const currentDir = getCurrentDir();
            if (!currentDir) {
                printOutput('Error: Invalid directory path.', true);
                return;
            }

            const items = Object.keys(currentDir).sort();
            if (items.length === 0) return;

            // Simple responsive grid output
            let outputHtml = '<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-y-1">';

            items.forEach(item => {
                const itemData = currentDir[item];
                let className = 'file-color';
                if (itemData.type === 'dir') {
                    className = 'dir-color';
                    item = item + '/'; // Append slash for folders
                } else if (item.endsWith('.exe') || itemData.type === 'link') {
                    className = 'exe-color';
                }

                outputHtml += `<span class="${className}">${item}</span>`;
            });

            outputHtml += '</div>';
            printOutput(outputHtml);
        };

        /** Changes the current working directory. */
        const handleCd = (targetDir) => {
            if (!targetDir || targetDir === '') {
                cwd = ['userDevKataria'];
                updatePrompt();
                return;
            }

            const currentDir = getCurrentDir();

            // Split path into parts
            const parts = targetDir.split('/');

            // Make a copy of cwd to manipulate
            let newCwd = [...cwd];

            for (const part of parts) {
                if (part === '.' || part === '') continue; // Current dir
                else if (part === '..') {
                    if (newCwd.length > 1) newCwd.pop(); // Prevent going above root
                } else {
                    const tempDir = getDirFromCwd(newCwd); // Helper to get dir object from path
                    if (!tempDir[part]) {
                        printOutput(`cd: no such file or directory: ${targetDir}`, true);
                        return;
                    } else if (tempDir[part].type !== 'dir') {
                        printOutput(`cd: not a directory: ${targetDir}`, true);
                        return;
                    } else {
                        newCwd.push(part);
                    }
                }
            }

            cwd = newCwd;
            updatePrompt();
        };

        // Helper to get directory object from arbitrary cwd
        const getDirFromCwd = (pathArray) => {
            let current = fileSystem;
            for (const dirName of pathArray) {
                if (current[dirName] && current[dirName].type === 'dir') {
                    current = current[dirName].contents;
                } else {
                    return null;
                }
            }
            return current;
        };

        /** Displays the content of a file. */
        const handleCat = (fileName) => {
            const currentDir = getCurrentDir();
            const file = currentDir[fileName];

            if (!file) {
                printOutput(`cat: ${fileName}: No such file or directory`, true);
            } else if (file.type === 'dir') {
                printOutput(`cat: ${fileName}: Is a directory`, true);
            } else if (file.type === 'file' || file.type === 'link') {
                printOutput(formatContent(file.content));
            }
        };

        /** Executes virtual executables (links). */
        const handleOpen = (fileName) => {
            const currentDir = getCurrentDir();
            const file = currentDir[fileName];

            if (!file) {
                printOutput(`open: ${fileName}: No such file or executable`, true);
            } else if (file.type === 'dir') {
                printOutput(`open: ${fileName}: Cannot open a directory`, true);
            } else if (fileName.endsWith('.exe') && file.type === 'link') {
                window.open(file.content, '_blank');
                printOutput(`Opened ${fileName} in a new tab...`);
            } else if (fileName.endsWith('.txt')) {
                printOutput(`To open a .txt file, please use the 'cat' command.`, true);
            } else {
                printOutput(`open: ${fileName}: Unknown file type or command is not designed to execute this file.`, true);
            }
        };

        /** Displays user context. */
        const handleWhoami = () => {
            printOutput(`User: <span class="prompt-color">${userName}</span>`);
            printOutput(`Environment: <span class="prompt-color">${hostName} (Linux kernel 5.10.10)</span>`);
        };

        /** Clears the terminal history. */
        const handleClear = () => {
            outputHistory.innerHTML = '';
        };

        // --- MAIN COMMAND PROCESSING ---

        const processCommand = (input) => {
            if (!input) return;

            // 1. Log command and add to history
            printCommand(input);
            commandHistory.push(input);
            historyIndex = commandHistory.length; // Reset history index

            const parts = input.trim().split(/\s+/);
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            switch (command) {
                case 'info':
                case 'help':
                    handleInfo();
                    break;
                case 'ls':
                    handleLs();
                    break;
                case 'cd':
                    handleCd(args[0]);
                    break;
                case 'cat':
                    handleCat(args[0]);
                    break;
                case 'open':
                    handleOpen(args[0]);
                    break;
                case 'clear':
                    handleClear();
                    break;
                case 'whoami':
                    handleWhoami();
                    break;
                case '':
                    // Do nothing if command is empty
                    break;
                default:
                    printOutput(`-bash: ${command}: command not found. Try 'info' for available commands.`, true);
            }
        };


        // --- EVENT LISTENERS ---

        commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const input = commandInput.value.trim();
                processCommand(input);
                commandInput.value = '';
                autocompleteState = null; // reset autocomplete
            } 
            else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[historyIndex];
                }
            } 
            else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    commandInput.value = '';
                }
            } 
            else if (e.key === 'Tab') {
                e.preventDefault();
                handleAutocomplete();
            }
        });

        let autocompleteState = null;

        const handleAutocomplete = () => {
            let input = commandInput.value;
            let parts = input.split(' ');
            let cmd = parts[0];
            let arg = parts.slice(1).join(''); // path to autocomplete

            if (!arg && cmd !== 'cd' && cmd !== 'cat' && cmd !== 'open') return;

            // Split path into directory + prefix
            let pathParts = arg.split('/');
            let prefix = pathParts.pop(); // the part we're completing

            // Resolve directory
            let tempCwd = [...cwd];
            for (const part of pathParts) {
                if (part === '..') {
                    if (tempCwd.length > 1) tempCwd.pop();
                } else if (part !== '.' && part !== '') {
                    const tempDir = getDirFromCwd(tempCwd);
                    if (!tempDir[part] || tempDir[part].type !== 'dir') return;
                    tempCwd.push(part);
                }
            }

            const targetDir = getDirFromCwd(tempCwd);
            if (!targetDir) return;

            // Filter items starting with prefix
            const matches = Object.keys(targetDir).filter(item => item.startsWith(prefix));
            if (matches.length === 0) return;

            if (matches.length === 1) {
                // Single match
                pathParts.push(matches[0]);
                if (targetDir[matches[0]].type === 'dir') pathParts[pathParts.length - 1] += '/';
                parts[1] = pathParts.join('/');
                commandInput.value = cmd + ' ' + parts.slice(1).join(''); // keep space after command
                autocompleteState = null;
            } else {
                // Multiple matches: cycle
                if (!autocompleteState || autocompleteState.items.join() !== matches.join()) {
                    autocompleteState = { items: matches, index: 0, pathParts: [...pathParts] };
                } else {
                    autocompleteState.index = (autocompleteState.index + 1) % matches.length;
                }
                let selected = autocompleteState.items[autocompleteState.index];
                let newPathParts = [...autocompleteState.pathParts, selected];
                parts[1] = newPathParts.join('/');
                commandInput.value = cmd + ' ' + parts.slice(1).join('');
            }
        };


        // Autofocus on the input field when the body is clicked
        document.body.addEventListener('click', () => {
            commandInput.focus();
        });


        // --- INITIALIZATION ---

        const initTerminal = () => {
            updatePrompt();
            commandInput.focus();
            
            // Print welcome message and initial help using 'cat info.txt' logic
            const rootContents = fileSystem.userDevKataria.contents;
            const infoFile = rootContents['info.txt'];
            printOutput('Dev Kataria Terminal Portfolio [Version 1.0.0]');
            printOutput('Copyright (c) 2025 Dev Kataria. All rights reserved.');
            printOutput('');
            if (infoFile) {
                printOutput(formatContent(infoFile.content));
            } else {
                 printOutput('Error: info.txt file not found.', true);
            }
            printOutput('');

        };

        window.onload = initTerminal;
    </script>

</body>
</html>
